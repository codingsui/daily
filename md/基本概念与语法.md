[TOC]
# 基础概念
## 什么是spring？
Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。
![image](http://note.youdao.com/yws/public/resource/53b088853ba2efc078c3e41f7996b610/xmlnote/B8B77C586E3046B9A6AA86D1B2B539E4/16465)

- **Spring Core：** 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。
- **Spring Aspects** ： 该模块为与AspectJ的集成提供支持。
- **Spring AOP** ：提供了面向切面的编程实现。
- **Spring JDBC** : Java数据库连接。
- **Spring JMS** ：Java消息服务。
- **Spring ORM** : 用于支持Hibernate等ORM工具。
- **Spring Web** : 为创建Web应用程序提供支持。
- **Spring Test** : 提供了对 JUnit 和 TestNG 测试的支持。

## 常用注解

- @Targert：用来标注所需要的目标

  - ```
    CONSTRUCTOR:用于描述构造器
    FIELD:用于描述域
    LOCAL_VARIABLE:用于描述局部变量
    METHOD:用于描述方法
    PACKAGE:用于描述包
    PARAMETER:用于描述参数
    TYPE:用于描述类、接口(包括注解类型) 或enum声明
    ```

- @Retention：表明注解的生命周期

  - ```
    SOURCE:在源文件中有效（即源文件保留）
    CLASS:在class文件中有效（即class保留）
    RUNTIME:在运行时有效（即运行时保留）
    ```

- @Documented：在生成javadoc文档的时候将该Annotation也写入到文档中

- @Inherited：标明该注解可以被子类注解继承

- @EnableAutoConfiguration：扫描项目所有的配置

  - ![image](http://note.youdao.com/yws/public/resource/53b088853ba2efc078c3e41f7996b610/xmlnote/73DE7C5B8607489C9E55B72D2BBCCFE2/17134)

- @EnableXxx：一般用于开启某一项功能，是为了简化代码的导入，即使用了该类注解，就会自动导入某些类。所以该类注解是组合注解，一般都会组合一个@import注解，用于导入指定的多个类，而被导入的类一般分为三种：配置类、选择器和注解器

  - 配置类：@Import中一般以Confiruration结尾，@Configuration修饰
  - 选择器：@Import中以Selector结尾，表示当前类根据条件选择导入不同的类
  - 注解器：@Import中以Registrar结尾，该类可以在代码运行时动态注册需要的类

## @RestController vs @Controller区别

单独使用 `@Controller` 不加 `@ResponseBody`的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。

但`@RestController`只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。

**@Controller +@ResponseBody 返回JSON 或 XML 形式数据**

## @PostConstruct和@PreDestroy

1. **`@PostConstruct`** : 用来修饰方法，标记在项目启动的时候执行这个方法,一般用来执行某些初始化操作比如全局配置。`PostConstruct` 注解的方法会在构造函数之后执行,Servlet 的`init()`方法之前执行。
2. **`@PreDestroy`** : 当 bean 被 Web 容器的时候被调用，一般用来释放 bean 所持有的资源。。`@PreDestroy` 注解的方法会在Servlet 的`destroy()`方法之前执行。

修饰条件

- 非静态
- 该方法必须没有任何参数，除非在拦截器的情况下，在这种情况下，它接受一个由拦截器规范定义的InvocationContext对象
- void()也就是没有返回值
- 该方法抛出未检查的异常

但是这两个注解在java9中弃用了，好的代替方案

```java
@Configuration
public class MyConfiguration2 implements InitializingBean, DisposableBean {
    public MyConfiguration2() {
        System.out.println("构造方法被调用");
    }

    @Override
    public void afterPropertiesSet() {
        System.out.println("afterPropertiesSet方法被调用");
    }

    @Override
    public void destroy() {
        System.out.println("destroy方法被调用");
    }

}
```

## @Resource和@Autowired

> https://blog.csdn.net/u012102104/article/details/79481007
>
> https://blog.csdn.net/balsamspear/article/details/87936936?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare
>
> https://www.cnblogs.com/otis/p/13066883.html

*@Resouce*

- 指定name和type，通过name找到唯一的been，找不到抛异常，找到如果type和类型不一致抛异常
- 指定name，通过name找到唯一bean，找不到抛异常
- 指定type，通过type找到唯一bean，找不到抛异常
- 不指定，先通过字段名作为name去匹配，找不到通过字段类型查找，如果不唯一，则抛出异常：`NoUniqueBeanDefinitionException`

*@Autowired*

只有一个属性是require，如果为false，找不到就赋值为null，默认为true找不到抛异常。

按照类型查找，如果bean不唯一抛出异常，可通过组合注解解决`@Autowired()@Qualifier("baseDao")`

| 注解对比 | `@Resource` | `@Autowire` |
| -------- | ----------- | ----------- |
| 注解来源 | JDK         | Spring      |
| 装配方式 | 优先按名称  | 优先按类型  |
| 属性     | name、type  | required    |

可能遇到的问题

1. 多个同名bean，报出ConflictingBeanDefinitionException，用`@Component("aaaa")`解决

```
@Component
public class A{}

@Component
public class A{}
不同包
```

2. 多个同名bean，引用注入的时候无法辨别用哪一个实例，报出NoUniqueBeanDefinitionException，用指定bean名称解决

```
@Component("a1")
public class A implements Base{}

@Component("a2")
public class A implements Base{}

@Autowired
private Base base;
```

## spring常用注解？

![1605598628228](C:\Users\suiyiliang\AppData\Roaming\Typora\typora-user-images\1605598628228.png)

## 什么是IOC？

> https://www.iteye.com/blog/jinnianshilongnian-1413846

控制反转，是一种设计思想，传统的我们使用对象是在对象内部直接控制，而IOC就是将我们的对象托管给IOC容器控制。传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象。这样的目的是让我们的程序更加的解耦

![image](http://note.youdao.com/yws/public/resource/53b088853ba2efc078c3e41f7996b610/xmlnote/94DF1A9F33F64BE4B197B63FA86483E8/16491)

### IOC容器实现原理？

ioc容器创建（其实就是类实例化，但是还没有属性赋值等操作）-------->加载所有bean的定义信息-------->创建bean的实例--------->属性赋值（调用bean的setxxx方法）---------->假如bean实现了xxxAware接口，就执行setXXX方法---------->执行初始化方法（相当于xml<bean init-method="初始化方法">）----------->ioc容器创建完成，执行一些逻辑代码------------->Web应用关闭，ioc容器销毁。

详细参考springboot的启动原理

## 什么是DI？

依赖注入，组件之间的依赖关系由容器在运行期间决定，**由容器动态的将某个依赖关系注入到组件之中**。**依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。**通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。

### 依赖注入的方式？

1. 构造器
2. setter方法
3. 静态工厂
4. 实例工厂

## 什么是aop？

AOP为面向切面编程，底层是通过动态代理实现，实质上就是将相同逻辑的重复代码横向抽取出来, 拦截对象方法，对方法进行改造、增强！比如在 **方法执行前**、**方法返回后**、**方法前后**、**方法抛出异常后** 等地方进行一定的增强处理，应用场景： 事务、日志、权限、监控打点

基于动态代理来实现，在容器启动的时候生成代理实例。默认地，如果使用接口的，用 JDK 提供的动态代理实现，如果没有接口，使用 CGLIB 实现

### aop用法？

AOP注解

类注解@Aspect

5大方法注解注解

[-@Before](mailto:-@Before)前置通知，目标方法执行之前所执行的方法可以获取方法名和参数列表

[-@After](mailto:-@After)后置通知 在目标方法执行之后所执行的方法

[-@AfterRunning](mailto:-@AfterRunning)返回通知，在目标方法返回时所执行的方法

[-@AfterThrowing](mailto:-@AfterThrowing)异常通知，在目标方法出现异常时会执行的代码，可以访问到异常对象；且可以指定在出现特定异常时在执行通知代码

[-@Around](mailto:-@Around)环绕通知，需要携带ProceedingJoinPoint类型的参数，类似于动态代理的全过程：ProceedingJoinPoint类型的参数可以决定是否执行目标方法，且环绕通知必须有返回值，返回值即目标方法的返回值。且这个注解的功能一个就可以完成以上四个功能

```java
@Pointcut(" ")
public void declareJointPointExpression(){}
其他注解中调用
eg:@Before("declareJointPointExpression()")

```

### 如何制定aop的执行顺序？

在类外可以用@Order(数字)指定优先级，数字越大优先级越低。

### aop的应用场景？

1. Authentication 权限

2. Caching 缓存
3. Context passing 内容传递
4. Error handling 错误处理
5. Lazy loading 懒加载
6. Debugging 调试
7. logging, tracing, profiling and monitoring 记录跟踪 优化 校准
8. Performance optimization 性能优化
9. Persistence 持久化
10. Resource pooling 资源池
11. Synchronization 同步
12. Transactions 事务

### aop的代理方式有哪些？

Spring 提供了两种方式来生成代理对象: JDKProxy 和 Cglib，具体使用哪种方式生成由
AopProxyFactory 根据 AdvisedSupport 对象的配置来决定。默认的策略是如果目标类是接口，
则使用 JDK 动态代理技术，否则使用 Cglib 来生成代理。

## spring、springmvc、springboot的区别？

Spring 是一个“引擎”;
Spring MVC 是基于Spring的一个 MVC 框架;
Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。

## SPRING的@IMPORT注解简单介绍

作用：

1. 将没有使用@Component注解的普通class加入到Spring容器, 由Spring管理
2. 导入一个Configuration类(比如你想组合多个Java Config类到一个Java Config类, 或者你引入的第三方jar包中的Java Config类没在你SpringBoot程序的子包下, 即没有被扫描进Spring容器)
3. 通过实现了ImportSelector接口的类, 导入多个class到Spring容器(**SpringBoot的自动装配@EnableAutoConfiguration**)
4. 通过实现**ImportBeanDefinitionRegistrar**接口的方式(**MyBatis整合Spring: MapperScannerRegistrar.java和@MapperScan注解**)

## SpringMVC请求处理流程

> https://www.cnblogs.com/hamawep789/p/10840774.html

Spring 的模型-视图-控制器（MVC）框架是围绕一个 DispatcherServlet 来设计的，这个 Servlet
会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染
等，甚至还能支持文件上传。

![image](http://note.youdao.com/yws/public/resource/53b088853ba2efc078c3e41f7996b610/xmlnote/98C1EF97945E40C18372168A55CA34B8/16472)

1、 客户端浏览器发送请求，直接请求到请求`DispatcherServlet`
2、DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）。处理器映射器根据请求url找到具体的处理器，生成处理器对象Handler及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
3、DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller
4、HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet
5、DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。
6、DispatcherServlet将模型数据填充到视图中
7、DispatcherServlet将结果响应给用户

## Spring 框架中用到了哪些设计模式？

- **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring AOP 功能的实现。
- **单例设计模式** : Spring 中的 Bean 默认都是单例的。
- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。
- **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。

# springboot

> https://www.cnblogs.com/theRhyme/p/11057233.html

## 什么是sprinboot？

旨在简化Spring开发。**Spring Boot就是Spring，它做了那些没有它你自己也会去做的Spring Bean配置。**

## springboot的优点？

1. 开发基于 Spring 的应用程序很容易。
2. Spring Boot 项目所需的开发或工程时间明显减少，通常会提高整体生产力。
3. Spring Boot不需要编写大量样板代码、XML配置和注释。
4. Spring引导应用程序可以很容易地与Spring生态系统集成，如Spring JDBC、Spring ORM、Spring Data、Spring Security等。
5. Spring Boot遵循“固执己见的默认配置”，以减少开发工作（默认配置可以修改）。
6. Spring Boot 应用程序提供嵌入式HTTP服务器，如Tomcat和Jetty，可以轻松地开发和测试web应用程序。（这点很赞！普通运行Java程序的方式就能运行基于Spring Boot web 项目，省事很多）
7. Spring Boot提供命令行接口(CLI)工具，用于开发和测试Spring Boot应用程序，如Java或Groovy。
8. Spring Boot提供了多种插件，可以使用内置工具(如Maven和Gradle)开发和测试Spring Boot应用程序。

## @SpringBootApplication功能？

这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加。为了省事，避免了我们每次开发 Spring Boot 项目都要写一些必备的注解。这一点在我们平时开发中也经常用到，比如我们通常会提一个测试基类，这个基类包含了我们写测试所需要的一些基本的注解和一些依赖。上`@Configuration`、`@EnableAutoConfiguration`、`@ComponentScan` 注解的集合。

- `@EnableAutoConfiguration`：启用 SpringBoot 的自动配置机制，借助@Import，从classpath中搜索所有的META-INF/spring.factories配置文件，并其中对应的配置项通过反射实例化为对应的标注了@Configuration的javaConfig形式的IOC容器配置类，汇总到一个加载到IOC容器。
- `@ComponentScan`： 扫描被`@Component` (`@Service`,`@Controller`)注解的 bean，将其加载到IOC容器，注解默认会扫描该类所在的包下所有的类。
- `@Configuration`：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类

```java
@Target(ElementType.TYPE) // 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明
@Retention(RetentionPolicy.RUNTIME) // 注解的生命周期，保留到class文件中（三个生命周期）
@Documented // 表明这个注解应该被javadoc记录
@Inherited // 子类可以继承该注解
@SpringBootConfiguration // 继承了Configuration，表示当前是注解类,会被扫描并加载到IOC容器
@EnableAutoConfiguration // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助
@ComponentScan(excludeFilters = { // 扫描路径设置（具体使用待确认）
@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
...
}　　
```

### 注解@ComponentScan，请谈一下你对这个注解的认识

该注解仅仅就是配置了一下用于进行组件扫描的指令参数，并没有进行扫描，真正扫描并装配这些类是@EnableAutoConfiguration 完成的。而这些指令参数就是通过该注解的属性进行配置的，例如扫描哪里，扫描之前可以先进行怎样的过滤等。如果这些注解属性都没有配置，则默认会扫描当前注解所标注类所在的包及其子孙包。不过，对于这点，Spring Boot1.x 版本中仅会扫描当前标注类所在包的子孙包，不会扫描标注类所在的包。但 Spring Boot2.x 版本中默认会扫描当前注解所标注类所在的包及其子孙包。对于一个 Spring Boot 工程，与自动配置相关的 Bean 均是由 Spring 容器管理的。而这些Bean 的类型根据创建者的不同可以分为两种：一种是由程序员自定义的组件类，例如我们自己定义的处理器类、Service 类等；另一种是框架本身已经定义好的自动配置相关类。自定义类由@ComponentScan 指定的扫描指令进行扫描，而框架自身的自动配置相关类在一个配置文件中存放，将来会被加载到内存。这两种类型的类都会由注解@EnableAutoConfiguration 交给 Spring 容器来管理。

### 注解解@EnableAutoConfiguration，请谈一下你对这个注解的认识

@Enable 开头这一类注解一般用于开启某一项功能，是为了简化代码的导入，即使用了该类注解，就会自动导入某些类。所以该类注解是组合注解，一般都会组合一个@Import 注解，用于导入指定的多个类。@EnableXxx 的功能主要体现在这些被导入的类上，而被导入的类一般有三种：配置类、可以实现动态选择的选择器，与可以完成动态注解的注册器。，该注解用于完成自动配置相关的自定义类及内置类的加载。其本身也是一个组合注解。除了元注解外，还组合了@Import 与@AutoConfigurationPackage 两个注解。具体

分工如下：

-  @Import：用于加载 Spring Boot 中内置的及导入 starter 中 META-INF/spring.factory 配置中的自动配置类。
- @AutoConfigurationPackage：用于扫描、加载并注册自定义的组件类。

![image](http://note.youdao.com/yws/public/resource/53b088853ba2efc078c3e41f7996b610/xmlnote/73DE7C5B8607489C9E55B72D2BBCCFE2/17134)

## springboot的实现原理？

加载 Spring Boot 配置文件 application.yml，与完成自动配置。

而自动配置又包含以下两个大的步骤：加载自动配置相关的类，与扫描并注册自定义的

组件类。加载 Spring Boot 配置文件是在启动类的 run()方法执行时加载的。其大体要经历运行环

境准备、为环境准备过程添加监听、发布环境准备事件等步骤。自动配置 则 是由组合注解 @SpringBootApplication 所包含的子注解@EnableAutoConfiguration 完成。其不仅加载了 META-INF/spring.factories 中内置的自动配置相关类，还完成了自定义类的加载与注册。若存在第三方 Starter，则其会将该 Starter 中META-INF/spring.factories 中的自动配置相关类加载并装配。

![image](http://note.youdao.com/yws/public/resource/53b088853ba2efc078c3e41f7996b610/xmlnote/40A834932EC147AFAE8A66FF34E8C766/16502)

```java
public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
		this.resourceLoader = resourceLoader;
		Assert.notNull(primarySources, "PrimarySources must not be null");
		this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
		this.webApplicationType = deduceWebApplicationType();
		setInitializers((Collection) getSpringFactoriesInstances(
				ApplicationContextInitializer.class));
		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
		this.mainApplicationClass = deduceMainApplicationClass();
	}
```

1.执行@SpringBootApplication

- @SpringBootConfiguration @ComponentScan @EnableAutoConfiguration

2.执行静态方法SpringApplication.run，会初始化SpringApplicaiton对象

- 通过SpringFactoriesLoader收集加载资源（所有的META-INF/spring.factories，映射类名到cache中）eg:`ApplicationContextInitializer` `ApplicationListener`相关的类初始化(排序后初始化)

3.执行 SpringApplicaiton对象的run方法

4.通过SpringFactoriesLoader获取到SpringApplicationRunListeners遍历并调用这些listeners的starting方法

5.初始化Environment，执行listener的environmentPrepared()

6.打印banner信息，spring的横幅

7.创建ApplicationContext，判断是否为Web的WebApplication的Context

8.执行listener的contextPrepared()方法，将@EnableAutoConfiguration获得的变量以及其他形式加载到IOC容器的配置加载到ApplicationContext，执行listener的contextLoaded()

9.refreshContext()

- prepareRefresh，刷新context，初始化placeHolder占位符属性，在上下文环境校验所有的properties文件
- prepareBeanFactory，刷新BeanFactory并为context准备BeanFactory
- postProcessBeanFactory，允许在上下文子类中对bean工厂进行后处理。
- invokeBeanFactoryPostProcessors（beanFactory），调用在上下文中注册为bean的工厂处理器。
- registerBeanPostProcessors（beanFactory），注册拦截Bean创建的Bean处理器。
- initMessageSource（），为此上下文初始化消息源。
- initApplicationEventMulticaster（），为此上下文初始化事件多播器。
- onRefresh（），在特定上下文子类中初始化其他特殊bean。eg：createWebServer
- registerListeners（），检查监听器bean，并注册它们。
- finishBeanFactoryInitialization（beanFactory），实例化所有剩余的（非延迟初始化）单例。
- finishRefresh（），最后一步：发布相应的事件。

10.afterRefresh

11.执行listener的started方法

12.callRunners

13.执行listener的running方法

## Spring boot自动配置的理解

Spring Boot 与 SSM 传统开发相比，其最大的特点是自动配置，不用再在 xml 文件中做大量的配置了。自动配置的实现主要是通过自动配置类来完成的，自动配置类存在于两类位置：一个是 Spring Boot 框架中内置的，一是从外部引入的 Starter 中。具体来说，自动配置类的作用就是根据条件创建核心业务类的实例到 Spring 容器中，以备该 Starter 的引用工程类中注入。当然，自动配置类还有一个作用：若创建核心业务类时需要获取配置文件中的相关属性值，其也会将这些属性值封装为一个属性实例，以备核心业务类使用。当然，自动配置类需要在 META-INF/spring.factories 中注册。所以自动配置其实就是能够自动获取配置文件中的属性并创建相应核心业务类实例。

## 自动注入可以用哪些注解？

- `@Component` ：通用的注解，可标注任意类为 `Spring` 组件。如果一个 Bean 不知道属于哪个层，可以使用`@Component` 注解标注。
- `@Repository` : 对应持久层即 Dao 层，主要用于数据库相关操作。
- `@Service` : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
- `@Controller` : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。：
- `@Autowired`：
- `@Resiyrce`：

## 如何自定义一个start？

对于自定义 Starter，其工程命名格式为{name}-spring-boot-starterConfiguration。工程需要导入配置处理器依赖。然工程中需要定义如下的类与配置：

- 定义核心业务类，这是该 Starter 存在的意义。
- 定义自动配置类，其完成对核心业务类的实例化。
- 若核心业务类中需要从配置文件获取配置数据，还需要定义一个用于封装配置文件中相关属性的类。
- 定义 META-INF/spring.factories 配置文件，用于对自动配置类进行注册。

## Spring bean

### spring bean的作用域有哪些？

- singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。单线程下是不安全的。
- prototype : 原型模式，每次通过spring容器获取bean都会创建一个实例
- request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。
- session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。
- global session：在一个全局的Http session中，容器会返回一个bean的同一个实例。仅在使用portlet context时有效

```java
@Bean
@Scope("singleton")
public Person personSingleton() {
    return new Person();
}
```

### Spring 中的单例 bean 的线程安全问题了解吗？

主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。eg：SimpleDateFormate

常见的有两种解决办法：

1. 在Bean对象中尽量避免定义可变的成员变量（不太现实）。
2. 在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。

### spring bean的生命周期

> https://www.cnblogs.com/zrtqsk/p/3735273.html
>
> ​	https://www.cnblogs.com/javazhiyin/p/10905294.html



![image](http://note.youdao.com/yws/public/resource/53b088853ba2efc078c3e41f7996b610/xmlnote/1CBB580B0172421EB5F273DAF6110CC7/16470)
![image](http://note.youdao.com/yws/public/resource/53b088853ba2efc078c3e41f7996b610/xmlnote/81D1194E45774B079C2391951583059B/16507)

1. Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化
2. Bean实例化后对将Bean的引入和值注入到Bean的属性中
3. 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法
4. 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入
5. 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。
6. 如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。
7. 如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用
8. 如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。
9. 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。
10. 如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。

    ```java
    public void refresh() throws BeansException, IllegalStateException {
        Object var1 = this.startupShutdownMonitor;
        //启动监控标识，并且同步此对象，防止同一时间有多个
        //线程加载
        synchronized(this.startupShutdownMonitor) {
            //初始化一些上下文参数
            this.prepareRefresh();
            //创建一个BeanFactory，进去后只有两个方法this.refreshBeanFactory(); 
            //return this.getBeanFactory();
            //具体的实现在它的父类AbstractRefreshableApplicationContext中
            
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            //为 此beanFactory初始化一些组件，比如：ClassLoadder等等
            this.prepareBeanFactory(beanFactory);
     
            try {
                //获取容器级别的后处理器，允许上下文的子类中对
                //beanFactory进行后处理，在应用上下文内部beanFactory
                //初始化之后可以修改beanFactory,此时所有的BeanDefinittions都
                //已经被加载，但未被实例化，具体的实现在AbstractRefreshableWebApplicationContext
                this.postProcessBeanFactory(beanFactory);
                /**在装配完成配置后执行这些后处理器，这里涉及到一些接口
                我们在开发时可以实现这些接口扩展功能，例如：
                InstantiationAwareBeanPostProcessor包含两个方法
                一个是在实例化前调用，一个在实例化后，初始化前调用
                可以用来做特殊作用，例如代理等等
                DestructionAwareBeanPostProcessor在销毁前调用
                */
                this.invokeBeanFactoryPostProcessors(beanFactory);
                /**
                把所有的bean的后处理器排序，在bean实例化后调用
                */
                this.registerBeanPostProcessors(beanFactory);
                //初始化国际化信息资源
                this.initMessageSource();
                //初始化事件多播组件，Event触发时由Multicaster
                //通知ApplicationListener
                this.initApplicationEventMulticaster();
                //空方法由子类扩展，可以在实例化bean之前
                //做一些ApplicationContext相关的操作
                this.onRefresh();
                //注册事件监听器
                this.registerListeners();
                //单例模式的bean实例 化，初始化等等完成
                this.finishBeanFactoryInitialization(beanFactory);
                //applicationContext刷新完成后的处理，
                //例如生命周期监听器的回调，广播通知等
                this.finishRefresh();
            } catch (BeansException var9) {
                if(this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9);
                }
                //如果加载失败，则清理环境相关的信息
                this.destroyBeans();
                //把applicationContext的active设置成false
                this.cancelRefresh(var9);
                throw var9;
            } finally {
                //清理一些缓存
                this.resetCommonCaches();
            }
     
        }
    }
    ```

### **BeanFactory 和ApplicationContext的区别**

BeanFactory和ApplicationContext都是接口，并且ApplicationContext间接继承了BeanFactory。

BeanFactory是Spring中最底层的接口，提供了最简单的容器的功能，只提供了实例化对象和获取对象的功能，而ApplicationContext是Spring的一个更高级的容器，提供了更多的有用的功能。  

ApplicationContext提供的额外的功能：获取Bean的详细信息(如定义、类型)、国际化的功能、统一加载资源的功能、强大的事件机制、对Web应用的支持等等。

加载方式的区别：BeanFactory采用的是**延迟加载的**形式来注入Bean；ApplicationContext则相反的，它是在Ioc**启动**时就一次性创建**所有的Bean,**好处是可以马上发现Spring配置文件中的错误，坏处是造成浪费。

### Bean的循环依赖了解么？

由于bean生命周期的特殊化，是先调用构造函数实例化再填充属性的，然后接着进行其他附加操作和初始化，才有了Spring的解决循环依赖，这样的解决机制是根据Spring框架内定义的三级缓存来实现的，也就是说：三级缓存解决了Bean之间的循环依赖。

- singletonObjects：第一级缓存，里面放置的是已经实例化好的单例对象；
- earlySingletonObjects：第二级缓存，里面存放的是提前曝光的单例对象；
- singletonFactories：第三级缓存，里面存放的是将要被实例化的对象的对象工厂。

所以当一个Bean调用构造函数进行实例化后，即使set属性还未填充，就可以通过**三级缓存**向外暴露依赖的引用值进行set（所以循环依赖问题的解决也是基于Java的引用传递），这也说明了另外一点，基于构造函数的注入，如果有循环依赖，Spring是不能够解决的。还要说明一点，Spring默认的Bean Scope是**单例**的，而三级缓存中都包含singleton，可见是对于单例Bean之间的循环依赖的解决，Spring是通过三级缓存来实现的。

```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		Object singletonObject = this.singletonObjects.get(beanName);
		if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
			synchronized (this.singletonObjects) {
				singletonObject = this.earlySingletonObjects.get(beanName);
				if (singletonObject == null && allowEarlyReference) {
					ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
					if (singletonFactory != null) {
						singletonObject = singletonFactory.getObject();
						this.earlySingletonObjects.put(beanName, singletonObject);
						this.singletonFactories.remove(beanName);
					}
				}
			}
		}
		return singletonObject;
	}
```

## 事务

### spring中事物隔离方式了解么？

**TransactionDefinition 接口中定义了五个表示隔离级别的常量：**

- **TransactionDefinition.ISOLATION_DEFAULT:** 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.
- **TransactionDefinition.ISOLATION_READ_UNCOMMITTED:** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**
- **TransactionDefinition.ISOLATION_READ_COMMITTED:** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**
- **TransactionDefinition.ISOLATION_REPEATABLE_READ:** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**
- **TransactionDefinition.ISOLATION_SERIALIZABLE:** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。



 ### spring中事物传播方式简单介绍一下

**支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRED：** 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- **TransactionDefinition.PROPAGATION_SUPPORTS：** 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- **TransactionDefinition.PROPAGATION_MANDATORY：** 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

**不支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRES_NEW：** 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NOT_SUPPORTED：** 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NEVER：** 以非事务方式运行，如果当前存在事务，则抛出异常。

**其他情况：**

- **TransactionDefinition.PROPAGATION_NESTED：** 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。

### @Transactional(rollbackFor = Exception.class)注解了解吗？

> https://developer.ibm.com/zh/articles/j-master-spring-transactional-use/

### 同一个类中调用 @Transaction注解的方法会有事务效果吗？

> https://blog.csdn.net/levae1024/article/details/82998386?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control

spring 在扫描bean的时候会扫描方法上是否包含@Transactional注解，如果包含，spring会为这个bean动态地生成一个子类（即代理类，proxy），代理类是继承原来那个bean的。此时，当这个有注解的方法被调用的时候，实际上是由代理类来调用的，代理类在调用之前就会启动transaction。然而，如果这个有注解的方法是被同一个类中的其他方法调用的，那么该方法的调用并没有通过代理类，而是直接通过原来的那个bean，所以就不会启动transaction，我们看到的现象就是@Transactional注解无效。

### 怎样解决这个问题？

1. 将两个方法写在不同的类中
2. 通过容器重新获取当前对象，然后通过注入的对象调用方法

## springboot中的异常处理

1. 使用 `@ControllerAdvice` 和 `@ExceptionHandler` 处理全局异常
2. `@ExceptionHandler` 处理 Controller 级别的异常
3. `ResponseStatusException`

## 什么是filter？

Filter 过滤器主要是用来过滤用户请求的，它允许我们对用户请求进行前置处理和后置处理，比如实现 URL 级别的权限控制、过滤非法请求等等。Filter 过滤器是面向切面编程——AOP 的具体实现（AOP切面编程只是一种编程思想而已）。

### springboot实现过滤器

1. 实现filter接口

```java
public interface Filter {
  
   //初始化过滤器后执行的操作
    default void init(FilterConfig filterConfig) throws ServletException {
    }
   // 对请求进行过滤
    void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException;
   // 销毁过滤器后执行的操作，主要用户对某些资源的回收
    default void destroy() {
    }
}
```

2. **在配置中注册自定义的过滤器。**

```
@Configuration
public class MyFilterConfig {
    @Autowired
    MyFilter myFilter;
    @Bean
    public FilterRegistrationBean<MyFilter> thirdFilter() {
        FilterRegistrationBean<MyFilter> filterRegistrationBean = new FilterRegistrationBean<>();

        filterRegistrationBean.setFilter(myFilter);

        filterRegistrationBean.setUrlPatterns(new ArrayList<>(Arrays.asList("/api/*")));

        return filterRegistrationBean;
    }
}
```

### 过滤器顺序？

方法1

```java
 @Bean
    public FilterRegistrationBean<MyFilter> setUpMyFilter() {
        FilterRegistrationBean<MyFilter> filterRegistrationBean = new FilterRegistrationBean<>();
        filterRegistrationBean.setOrder(2);
        filterRegistrationBean.setFilter(myFilter);
        filterRegistrationBean.setUrlPatterns(new ArrayList<>(Arrays.asList("/api/*")));

        return filterRegistrationBean;
    }

    @Bean
    public FilterRegistrationBean<MyFilter2> setUpMyFilter2() {
        FilterRegistrationBean<MyFilter2> filterRegistrationBean = new FilterRegistrationBean<>();
        filterRegistrationBean.setOrder(1);
        filterRegistrationBean.setFilter(myFilter2);
        filterRegistrationBean.setUrlPatterns(new ArrayList<>(Arrays.asList("/api/*")));
        return filterRegistrationBean;
    }
```

方法2

```
@Order
数值越小越先执行
```

## 什么是拦截器？

**拦截器(Interceptor)同** Filter 过滤器一样，它俩都是面向切面编程——AOP 的具体实现（AOP切面编程只是一种编程思想而已）。

你可以使用 Interceptor 来执行某些任务，例如在 **Controller** 处理请求之前编写日志，添加或更新配置......

在 **Spring中**，当请求发送到 **Controller** 时，在被**Controller**处理之前，它必须经过 **Interceptors**（0或更多）。

**Spring Interceptor**是一个非常类似于**Servlet Filter** 的概念 。

### 与过滤器的区别？

- 过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。
- 拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。

还可以这样理解：
（1）拦截器 ：是在面向切面编程的就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。

（2）过滤器：是在javaweb中，你传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的action进行业务逻辑，比如过滤掉非法url（比如请求地址中含有非法字符），或者在传入servlet或者 struts的action前统一设置字符集，或者去除掉一些非法字符.。

具体区别：

（1）拦截器是基于java的反射机制的，而过滤器是基于函数回调。

（2）拦截器不依赖于servlet容器，而过滤器依赖于servlet容器。

（3）拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。

（4）拦截器可以访问action上下文、值栈里的对象，而过滤器不能。

（5）在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。

### 拦截器和过滤器应用场景

拦截器应用场景：
1） 权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面
2） 日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。
3） 性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）
4） 通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现5）

过滤器应用场景：
1）过滤敏感词汇（防止sql注入）
2）这是字符编码
3）URL级别的权限访问控制
4）压缩响应信息

### 如何自定义拦截器？

 **Interceptor** 的话必须实现 **org.springframework.web.servlet.HandlerInterceptor**接口或继承 **org.springframework.web.servlet.handler.HandlerInterceptorAdapter**类，并且需要重写下面下面3个方法：

```java
public boolean preHandle(HttpServletRequest request,
                         HttpServletResponse response,
                         Object handler)
 
 
public void postHandle(HttpServletRequest request,
                       HttpServletResponse response,
                       Object handler,
                       ModelAndView modelAndView)
 
 
public void afterCompletion(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler,
                            Exception ex)
```

### 如何配置拦截器？

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // LogInterceptor apply to all URLs.
        registry.addInterceptor(new LogInterceptor());

        // Old Login url, no longer use.
        // Use OldURLInterceptor to redirect to a new URL.
        registry.addInterceptor(new OldLoginInterceptor())//
                .addPathPatterns("/admin/oldLogin");

        // This interceptor apply to URL like /admin/*
        // Exclude /admin/oldLogin
        registry.addInterceptor(new AdminInterceptor())//
                .addPathPatterns("/admin/*")//
                .excludePathPatterns("/admin/oldLogin");
    }

}
```

### 多拦截器的顺序？

1. 加入的顺序就是拦截器执行的顺序，preHandle顺序执行，posthandle逆序，afterCompletion逆序

## filter + interceptor 执行顺序

先执行filter，再执行interceptor，其中多filter和interceptor的执行顺序同自己。

## 传入参数校验

- `@Null` 被注释的元素必须为 null
- `@NotNull` 被注释的元素必须不为 null
- `@AssertTrue` 被注释的元素必须为 true
- `@AssertFalse` 被注释的元素必须为 false
- `@Min(value) `被注释的元素必须是一个数字，其值必须大于等于指定的最小值
- `@Max(value) `被注释的元素必须是一个数字，其值必须小于等于指定的最大值
- `@DecimalMin(value) `被注释的元素必须是一个数字，其值必须大于等于指定的最小值
- `@DecimalMax(value)` 被注释的元素必须是一个数字，其值必须小于等于指定的最大值
- `@Size(max=, min=) `被注释的元素的大小必须在指定的范围内
- `@Digits (integer, fraction) `被注释的元素必须是一个数字，其值必须在可接受的范围内
- `@Past `被注释的元素必须是一个过去的日期
- `@Future` 被注释的元素必须是一个将来的日期
- `@Pattern(regex=,flag=) `被注释的元素必须符合指定的正则表达式

搭配@RequestBody @Valid 使用


