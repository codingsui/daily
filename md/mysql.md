[TOC]

\# 基本概念

\## 什么事范式

范式本质上是一种规范，符合一种级别的关系模式集合，数据库范式分为1NF，2NF，3NF，BCNF，4NF，5NF（级别递增）。范式级别之间的关系也是层层递进的，符合高级别的范式必然符合低一级别的范式，一般我们设计关系型数据库的时候只用考虑BCNF范式即可。

\### XX范式的含义

\>https://blog.csdn.net/u013164931/article/details/79692402?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&dist_request_id=5d4b3817-679f-47a3-9725-4cd3a675c3a7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control

\- 1NF：所有属性不可再分，即数据项不可再分

\- 2NF：在第一范式的基础上，消除了非主属性对码的部分函数依赖

\- 3NF：在第二范式的基础上，消除了非主属性对码的传递函数依赖

\- BCNF：消除主属性之间的部分依赖于传递依赖

\- 4NF：

\- 5NF：

\## DDL和DML的区别

\- ML(Data Manipulation Language)数据操纵语言：对数据库中的数据进行一些简单操作，如insert,delete,update,select等。

\- DDL(Data Definition Language)数据定义语言：对数据库中的某些对象(例如，database,table)进行管理，如create、alter、drop、TRUNCATE、show等

区别：

1.DML操作是可以手动控制事务的开启、提交和回滚的。

2.DDL操作是隐性提交的，不能rollback！

\## delete，drop，truncate 都有删除表的作用，区别？

1、delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了

2、delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔

3、执行的速度上，drop>truncate>delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车

\## UNION使用

\- UNION 语句：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）

\- UNION ALL 语句：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）

\```

SELECT 列名称 FROM 表名称 UNION SELECT 列名称 FROM 表名称 ORDER BY 列名称；

SELECT 列名称 FROM 表名称 UNION ALL SELECT 列名称 FROM 表名称 ORDER BY 列名称；

\```

\# 基本信息查看（linux）

\### 最大连接数

\```sql

mysql> show variables like 'max_connections';

+-----------------+-------+

| Variable_name | Value |

+-----------------+-------+

| max_connections | 151 |

+-----------------+-------+

1 row in set (0.01 sec)

\```

\### 存储引擎

\```

mysql> show engines

\```

\### 查看当前数据库中的日志使用信息：

\```

mysql> show variables like 'log_%';

\```

\# mysql详解

\## mysql数据文件构成

查看MySQL数据文件：

```
SHOW VARIABLES LIKE '%datadir%';
```

1）**InnoDB数据文件**

**.frm**文件：**主要存放与表相关的数据信息,主要包括**表结构的定义信息**

**.ibd**：**使用**独享表空间**存储**表数据和索引**信息，一张表对应一个ibd文件。

**ibdata**文件：**使用**共享表空间**存储**表数据和索引信息，所有表共同使用一个或者多个ibdata文

件。

**2**）**MyIsam数据文件**

**.frm**文件：**主要存放与表相关的数据信息,主要包括**表结构的定义信息

**.myd**文件：**主要用来存储**表数据信息**。

**.myi**文件：**主要用来存储**表数据文件中任何索引的数据树。

\## mysql基础架构由什么组成？

大体上mysql可以分为两层，server层和存储引擎层，所有的存储引擎公用Server层。

Server层负责内置函数转换，存储过程，触发器，视图等工作。存储引擎层负责数据的存储和提取。

\## mysql server层组成

![image](http://note.youdao.com/yws/public/resource/53b088853ba2efc078c3e41f7996b610/xmlnote/B68819B6621D4C0884C9CC82AD17A388/17062)

\- 连接器： 与客户端建立连接，身份认证和权限相关(登录 MySQL 的时候)。

\- 主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。

\- 查询缓存: 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。

\- 查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。

连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。

MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。

\- **分析器:** 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。

\- MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：

**第一步，词法分析**，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。

**第二步，语法分析**，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。（经常我们写sql报错就在这层），如果语法正确就会根据Mysql定义的语法规则，根据sql语句生成一个数据结构，这个数据结构叫做解析树。

第三步，预处理器，会进一步检查解析树是否合法，比如表名是否存在，列是否存在等。会校验用户是否有表权限。预处理后会得到一个新的解析树。

完成这 3步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。

\- **优化器：** 按照 MySQL 认为最优的方案去执行。

\- 优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序以哪个表为基准表等。

\- **执行器:** 执行语句，然后从存储引擎返回数据。

\- 当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。

\# 常见问题

\## 一条sql语句是怎样在mysql中执行的？

其实我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：

\### 查询语句

\> https://blog.csdn.net/xcy1193068639/article/details/84673840

\```sql

select * from tb_student A where A.age='18' and A.name=' 张三 ';

\```

\- 连接器建立连接，查看是否有权限

\- 查询缓存（8.0后移除）

\- 分析器，词法分析，语法分析，预处理器

\- 优化器，确定执行方案

\- 执行器，判断表执行权限，调用引擎接口查取数据

\```

a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。

b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。

\```

\- 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

![image](http://note.youdao.com/yws/public/resource/53b088853ba2efc078c3e41f7996b610/xmlnote/A2029997BC1643819A5BC683682E1D2B/17068)

\### 更新语句

\> https://blog.csdn.net/xcy1193068639/article/details/84922580

\```update tb_student A set A.age='19' where A.name=' 张三 ```

![60f7485e69463a7bfbc19705b2e59f65.png](evernotecid://AFE78BA2-7240-4F53-A10F-425044D23A61/appyinxiangcom/16174389/ENResource/p33)

![2fbceb495e286454c3e29a1ed75ee31b.png](evernotecid://AFE78BA2-7240-4F53-A10F-425044D23A61/appyinxiangcom/16174389/ENResource/p32)

前面有介绍过SQL语句基本的执行链路，查询语句走的这一流程，更新语句也会走一遍。

\- 连接器校验权限

\- 查询缓存，是否有涉及表的缓存数据，如果有就清空该表的所有缓存数据

\- 分析器，词法分析、语法分析、预处理器

\- 优化器

\- 执行器

\- 执行器线找到引擎取 name='张三'这一行，如果改行所在的数据页本身就在内存中，就直接返回给执行器，否则先从磁盘读区到内存，然后再返回。

\- 执行器拿到引擎数据将进行更新操作，此时将age更新为19，得到新一行数据，然后再调用引擎接口写入这行新数据

\- 引擎将这行数据更新到内存中，同时将跟新操作记录到redo log里面，状态为prepare（预提交）状态，然后告诉执行器执行完成，可以提交事务了

\- 执行器生成这个操作的binlog，并把binlog写入磁盘

\- 执行器调用引擎的提交事务接口，引擎将刚刚写入的redo log改为commit（提交）状态，更新完成

如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：

\- 判断 redo log 是否完整，如果判断是完整的，就立即提交。

\- 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。

这样就解决了数据一致性的问题。

\### 为什么更新的时候要两阶段提交？

用反证法来进行解释。由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log再写 binlog，或者采用反过来的顺序

\- **先写redo log再写binlog**，假设redolog写完，binlog未写完，mysql异常重启了。我们知道redolog写完即使系统崩溃，仍然能把数据恢复回来，所以此时当前机器存在最新的数据修改操作，但是其他利用binlog进行数据同步的从库或者备份的数据就缺少一个数据，与原库不同了，产生 数据不一致问题。

\- **先写binlog，再写redo log**，假设binlog写完后crash，redolog没写，回复崩溃之后这个数据无效，所以当前的数据没有不是最新的修改，但是 binlog里面已经记录了最新的股改，此时其他利用binlog进行数据同步的从库或者备份的数据就多了一个数据，与原库不同了，产生 数据不一致问题。

\## 怎么让数据库恢复到半个月内任意一秒的状态？

binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份，这里的“定期”取决于系统的重要性。可以一天一备或者一周一备。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点又一次误删表，需要找回数据，那你可以这么做：

\- 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库。

\- 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。

这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。

\- 最后，临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。

\## innodb_flush_log_at_trx_commit和sync_binlog参数详解

| innodb_flush_log_at_trx_commit | |

| ------------------------------ | ------------------------------------------------------------ |

| 0 | 每秒将日志缓冲区写入log file，并同时flush到磁盘。跟事务提交无关。在机器crash并重启后，会丢失一秒的事务日志数据（并不一定是1s，也许会有延迟，跟操作系统调度有关）,在这种情况下，MySQL性能最好 |

| 1 | 每次事务提交将日志缓冲区写入log file(os cache)，并同时flush到磁盘。（crash不会丢失事务日志） |

| 2 | 每次事务提交将日志缓冲区写入log file(os cache)，每秒flush一次到磁盘。（crash有可能丢失数据） |

| sync_binlog | |

| ----------- | ------------------------------------------------------------ |

| 0 | （mysql默认值 ）不主动刷新二进制日志文件的数据到磁盘上，而是由操作系统决定 |

| 1 | 每提交一次事务，写一次binlog，并使用fdatasync()同步到硬盘 |

| > 1 | 每提交一次事务，写一次binlog，达到sync_binlog 设定的值后，调用fdatasync()同步到硬盘 |

\# 引擎

\## mysql相关的引擎介绍

| 存储引擎 | **说明** |

| ------------------- | ------------------------------------------------------------ |

| **MyISAM** | 高速引擎，拥有较高的插入，查询速度，**但不支持事务** |

| **InnoDB** | 5.5版本后MySQL的默认数据库，支持事务和行级锁定，比MyISAM处理速度稍慢 |

| ISAM | MyISAM的前身，MySQL5.0以后不再默认安装 |

| MRG_MyISAM（MERGE） | 将多个表联合成一个表使用，在超大规模数据存储时很有用 |

| **Memory** | **内存存储引擎，拥有极高的插入，更新和查询效率。**但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失 |

| Falcon | 一种新的存储引擎，支持事物处理，传言可能是InnoDB的替代者 |

| Archive | 将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作 |

| CSV | CSV 存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换) |